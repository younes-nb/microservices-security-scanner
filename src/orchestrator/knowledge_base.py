COMPONENT_GENERIC_STEREOTYPE_LIST = [
    {"name": "service", "description": "A backend component that implements business logic. It often exposes an API (like gRPC or REST) and connects to other services or databases. Prime examples include applications built with frameworks like Spring Boot (Java), ASP.NET Core (C#), Django/FastAPI/Flask (Python), or Express.js (Node.js)."},
    {"name": "database", "description": "A system that stores and retrieves data."},
    {"name": "message_broker", "description": "The central infrastructure that manages message distribution. **Identification Clues:** Look for service names in configurations like `rabbitmq`, `kafka`, `activemq`, or `nats`. The configuration will focus on ports and cluster settings, not business logic."},
    {"name": "pub_sub_component", "description": "An application component that sends (publishes) or receives (subscribes to) messages via a Message Broker. **Identification Clues:** Look for code that imports client libraries for a specific broker (e.g., `pika` for RabbitMQ, `kafka-python` for Kafka) and uses functions like `publish` or `subscribe`."},
    {"name": "event_sourcing", "description": "An architectural pattern where all application state changes are stored as a sequence of immutable events. **Identification Clues:** This is a code pattern. Look for a combination of an `Event Store` database and class names that consistently end in `...Event` (e.g., `OrderCreatedEvent`). The code will `apply` events to build state rather than using direct UPDATE commands."},
    {"name": "transactional_outbox_message_relay", "description": "A pattern to ensure an event is reliably sent if and only if a database transaction completes. **Identification Cl-ues:** Look for code that writes to both a business table and an `outbox` table in a single transaction. A separate background process then reads from the outbox and sends messages to a message broker."},
    {"name": "external_component", "description": "A system, service, or user that exists outside the boundaries of the application being analyzed but interacts with it. This is often an abstract concept for modeling interactions with third-party APIs (like a payment provider) or the end-user's client application."},
    {"name": "facade", "description": "A component that provides a single, simplified interface to a more complex set of underlying services. Its purpose is to hide internal complexity. **Identification Clues:** Look for a service that contains very little business logic of its own but makes many calls to other internal services, aggregating and simplifying their results for a client."},
    {"name": "replicated", "description": "This is not a component type but a quality applied to another component. It means multiple identical instances are running for high availability or scalability. **Identification Clues:** In `docker-compose.yaml`, look for a `deploy` key with a `replicas` field greater than 1. In Kubernetes, look for the `replicas` field in a `Deployment`."},
    {"name": "monitoring_component", "description": "A generic component related to observing system health."},
    {"name": "tracing_component", "description": "A component that collects and visualizes distributed traces to show a request's path through multiple services. **Identification Clues:** Look for services like `Jaeger` or `Zipkin`. In application code, look for dependencies on `OpenTelemetry`."},
    {"name": "logging_component", "description": "A component that collects and stores log files from other services. **Identification Clues:** Look for services like `Fluentd`, `Logstash`, or `Graylog`."},
    {"name": "monitoring_dashboard", "description": "A tool used *specifically for visualizing* metrics, logs, and traces. **Identification Clues:** Look for services like `Grafana` or `Kibana`. This is a UI for system data, not business data."},
    {"name": "monitoring_data_provider", "description": "A component that collects and exposes metrics for monitoring tools to scrape. **Identification Clues:** The most common example is `Prometheus`. In other services, look for libraries that expose a `/metrics` endpoint."},
    {"name": "circuit_breaker", "description": "A resilience pattern implemented *within* a service's code to prevent cascading failures when a downstream service is down. **Identification Clues:** This is not a separate service. Look for code dependencies like `Resilience4j` (Java) or `Polly` (.NET) and annotations like `@CircuitBreaker`."},
    {"name": "load_balancer", "description": "A component that distributes incoming traffic across multiple instances of a service. **Identification Clues:** Look for services like `HAProxy` or `Traefik`. `NGINX` can also act as a load balancer if it's configured with an `upstream` block."},
    {"name": "orchestrator", "description": "A central component that controls a workflow by making calls to other services in a defined sequence. It acts as the 'brain' of a business process."},
]

COMPONENT_STEREOTYPE_HIERARCHY_MAP = {
    "service": [
        {"name": "middleware_service", "description": "A custom-built, central service that provides a shared capability to other services. Its main purpose is to handle common, non-business-specific tasks like internal traffic routing, message format transformation, or centralized caching logic. It is a hub that other services rely on for a technical function, not a business feature. **Identification Clues:** The code will show connections to many other services but will lack primary business logic of its own (e.g., no 'User' or 'Product' domain models). The service's name might be generic, like 'internal-router', 'protocol-adapter', or 'cache-proxy'. **Crucially, it should be chosen only when a more specific type like 'API Gateway', 'Discovery Service', or 'Configuration Service' does not fit.**; Prefer a more specific type like 'discovery_service' or 'configuration_service' if possible."},
        {"name": "discovery_service", "description": "A component that continuously processes real-time data streams, often performing transformations or analytics. **Identification Clues:** Look for dependencies on frameworks like `Apache Kafka Streams`, `ksqlDB`, `Apache Flink`, or `Apache Spark Streaming`."},
        {"name": "configuration_service", "description": "A central registry that microservices use to find each other (a 'phone book' for services). **Identification Clues:** Look for service names like `eureka-server`, `consul`, or `zookeeper`. In other services, look for properties like `eureka.client.serviceUrl`."},
    ],
    "database": [
        {"name": "in_memory_data_store", "description": "A generic database that stores data primarily in RAM for very fast access. **Identification Clues:** This is a general category; prefer a more specific type like 'redis_db' or 'memcached_db' if possible."},
        {"name": "local_file_based_data_store", "description": "A database that stores its data in local files on the server's filesystem. **Identification Clues:** Look for the use of libraries like **SQLite** or H2 in file mode. The connection string will be a local file path, not a network address."},
        {"name": "postgresql_db", "description": "A powerful, open-source object-relational database. **Identification Clues:** Look for a service named `postgres` or `postgresql`. In code, look for client libraries like `psycopg2` (Python) or JDBC drivers for PostgreSQL."},
        {"name": "mysql_db", "description": "A very popular open-source relational database. **Identification Clues:** Look for a service named `mysql` or `mariadb`. In code, look for client libraries like `mysql-connector-python` or `mysql2` (Node.js)."},
        {"name": "sql_server", "description": "Microsoft's relational database system. **Identification Clues:** Look for a service name like `mssql` or `sql-server`. It is often used in projects built with .NET."},
        {"name": "mongo_db", "description": "A NoSQL, document-oriented database that stores data in JSON-like documents. **Identification Clues:** Look for a service named `mongo`. In code, look for dependencies like `pymongo` (Python) or `mongoose` (Node.js)."},
        {"name": "redis_db", "description": "A versatile in-memory data store used as a high-performance cache, session store, and message broker. **Identification Clues:** Look for a service named `redis` and client libraries like `redis-py` (Python)."},
        {"name": "ldap_store", "description": "A directory service protocol for storing and retrieving information about users and resources. **Identification Clues:** Look for a service like `openldap`. In code, look for libraries that perform LDAP operations like `bind` and `search`."},
        {"name": "elastic_search_store", "description": "A distributed search and analytics engine focused on full-text search. **Identification Clues:** Look for a service named `elasticsearch`. Application code will use its specific REST API and client libraries. Often used with `Kibana`."},
        {"name": "memcached_db", "description": "A high-performance, in-memory object caching system used to speed up applications by caching data. **Identification Clues:** Look for a service named `memcached` and client libraries like `pylibmc`."},
        {"name": "event_store", "description": "A specialized database designed for the Event Sourcing pattern. Its primary function is to append events to streams. **Identification Clues:** Look for a service named `eventstore-db` or application code that heavily uses `...Event` objects and functions like `appendToStream`."},
    ],
    "message_broker": [
        {"name": "stream_processing", "description": "A component that continuously processes real-time data streams, often performing transformations or analytics. **Identification Clues:** Look for dependencies on frameworks like `Apache Kafka Streams`, `ksqlDB`, `Apache Flink`, or `Apache Spark Streaming`."},
    ],
    "pub_sub_component": [
        {"name": "stream_processing", "description": "A component that continuously processes real-time data streams, often performing transformations or analytics. **Identification Clues:** Look for dependencies on frameworks like `Apache Kafka Streams`, `ksqlDB`, `Apache Flink`, or `Apache Spark Streaming`."},
    ],
    "event_sourcing": [
        {"name": "stream_processing", "description": "A component that continuously processes real-time data streams, often performing transformations or analytics. **Identification Clues:** Look for dependencies on frameworks like `Apache Kafka Streams`, `ksqlDB`, `Apache Flink`, or `Apache Spark Streaming`."},
    ],
    "external_component": [
        {"name": "web_browser", "description": "Represents the browser application itself (e.g., Chrome, Firefox). This is an **External Component** and is not found within the project's source code. The AI should not choose this for a service defined in the project."},
        {"name": "client", "description": "A generic, high-level category for a user-facing application that consumes backend services. This is a good fallback if a more specific client type isn't applicable. Prefer a more specific type like 'service_client_in_web_ui' if possible."},
        {"name": "service_client_in_web_ui", "description": "A more specific version of `web_ui` that acts as a 'thick client' with significant logic for communicating with backend services. **Identification Clues:** In addition to the `web_ui` clues, look for the use of data-fetching libraries like **axios** or **React Query**, or extensive use of the browser's `fetch()` API."},
        {"name": "application", "description": "A high-level category for a self-contained client program, often used for desktop applications. **Identification Clues:** Look for desktop frameworks like **Electron**, **WPF**, or **JavaFX**. Prefer a more specific type like 'mobile_application' if possible."},
        {"name": "mobile_application", "description": "A specific type of `application` designed for a mobile OS like iOS or Android. **Identification Clues:** Look for frameworks like **React Native** or **Flutter** (`pubspec.yaml`), or native project files like `.xcodeproj` (for iOS) or `build.gradle` within an Android project structure."},
    ],
    "facade": [
        {"name": "api_gateway", "description": "A specific type of Facade that acts as the main entry point for all external client requests. It handles cross-cutting concerns like routing, rate limiting, and sometimes authentication. **Identification Clues:** Look for services like `NGINX`, `Zuul`, `Spring Cloud Gateway`, or `Kong`. The configuration will consist mainly of routing rules (e.g., `proxy_pass` in NGINX) that map URL paths to different internal microservices."},
        {"name": "backends_for_frontends_gateway", "description": "A specialized API Gateway pattern where a separate gateway is created for each specific front-end client (e.g., one gateway for a mobile app, another for a web app). **Identification Clues:** You would identify this pattern if you see multiple gateway components in the architecture, each clearly named and configured to serve a different type of client."},
        {"name": "ui", "description": "Represents the graphical interface part of an application. Prefer a more specific type like 'web_ui' if possible."},
        {"name": "web_ui", "description": "A specific type of UI that runs in a web browser. **Identification Clues:** Look for a `package.json` file containing front-end frameworks like **React**, **Angular**, or **Vue**. The presence of HTML, CSS, and build tools like `vite.config.js` or `webpack.config.js` are strong indicators."},
    ],
    "orchestrator": [
        {"name": "saga_orchestrator", "description": "A specific type of Orchestrator that manages data consistency across microservices using the Saga pattern. **Identification Clues:** Look for code that defines a state machine for a business transaction and includes logic for `compensating transactions` to undo previous steps if a later step fails."},
    ],
}

SECURITY_COMPONENT_ANNOTATIONS = {
    "sensitive_data_in_component_code": [ 
        {"name": "component_code_no_sensitive_data", "description": "This is the ideal state. It means the code avoids hardcoded secrets and instead loads them from secure sources. **Identification Clues:** Look for code that reads secrets from **environment variables** (e.g., `os.getenv('API_KEY')`) or a dedicated secrets management service like **HashiCorp Vault** or **AWS Secrets Manager**."},
        {"name": "component_code_plaintext_sensitive_data", "description": "A high-risk security flaw where secrets are written directly into source code or configuration files. **Identification Clues:** Scan for keywords like **`password`**, **`secret`**, or **`apiKey`** followed by a hardcoded string value (e.g., `password = 'admin123'`)."},
        {"name": "component_code_encrypted_sensitive_data", "description": "A better practice where secrets in configuration files are encrypted, and the application decrypts them at runtime. **Identification Clues:** In configuration files (especially for Java Spring), look for values wrapped in a specific format like **`ENC(...)`**. The project dependencies will include a library like **Jasypt**."},
        {"name": "component_code_encrypted_token_sensitive_data", "description": "A specific case where the stored secret is a structured token (like a JWT) that is itself encrypted (a JWE - JSON Web Encryption). **Identification Clues:** Look for dependencies on **JWE** libraries and code that performs decryption on a compact token string."},
    ],
    "auth_provider": [
        {"name": "authentication_service", "description": "A specific microservice whose main job is to manage user identity and authentication logic. **Identification Clues:** Look for a dedicated service with API endpoints like `/login`, `/register`, and `/logout`. Its code will contain logic for password hashing and validating credentials against a user database."},
        {"name": "oauth2_server", "description": "A specific type of Auth Server that implements the OAuth 2.0 framework for delegated authorization. **Identification Clues:** Look for dependencies on OAuth 2.0 server libraries (e.g., `spring-security-oauth2-authorization-server`). The code will implement specific endpoints like `/oauth/authorize` and `/oauth/token`."},
        {"name": "identity_server", "description": "An Auth Server that often builds on OAuth 2.0 by adding the OpenID Connect (OIDC) layer to provide verifiable user identity information. **Identification Clues:** In addition to OAuth2 clues, look for the use of **JSON Web Tokens (JWTs)** and dependencies on OIDC or JWT libraries. The server will issue an `id_token`."},
    ],
    "csrf_protection": [
        {"name": "no_csrf_protection", "description": " Indicates a potential security weakness where the application has no specific mechanism to prevent CSRF. **Identification Clues:** Select this for a stateful web application if you find a complete **absence** of any CSRF-related libraries, middleware, or token validation logic."},
        {"name": "token_based_csrf_protection", "description": "The standard defense where the server generates a unique token for a user's session and validates it on subsequent state-changing requests (POST, PUT, DELETE). **Identification Clues:** Look for dependencies on libraries like **`csurf`** (for Node.js/Express) or **`Flask-WTF`** (for Python/Flask). Also, look for the application of CSRF middleware, such as `app.use(csrf())`."},
    ],
    "csrf_scope": [
        {"name": "csrf_scope_none", "description": "Indicates that no requests are protected against CSRF attacks. This is functionally equivalent to 'No CSRF Protection'."},
        {"name": "csrf_scope_some_requests", "description": "Indicates that CSRF protection is applied selectively, only to specific routes or endpoints, while others are unprotected. **Identification Clues:** Look for CSRF validation middleware or logic that is applied to individual routes rather than globally to the entire application."},
        {"name": "csrf_scope_all_requests", "description": "The ideal state where CSRF protection is applied globally as middleware, covering all potentially state-changing requests by default. **Identification Clues:** Look for CSRF middleware being applied at the application level (e.g., `app.use(csrf())` in an Express.js application). This is often the default behavior in frameworks like Django and Ruby on Rails."},
    ]
}

CONNECTOR_GENERIC_STEREOTYPE_LIST = [
    {"name": "directed", "description": "A connection that flows in a single, specific direction from a source component to a target component. **Identification Clues:** This is a fundamental quality of most other connector types. Almost all standard interactions, such as a RESTful HTTP API call, a gRPC request, or a component writing to a database, are considered directed. Select this if you could not find any specific connector type from bellow."},
    {"name": "synchronous_connector", "description": "A blocking request-response interaction where the caller sends a request and must wait for a response before it can continue its own execution (like making a phone call). **Identification Clues:** This is the most common interaction style. Standard **RESTful HTTP** API calls and unary **gRPC** requests are synchronous. This can also describe a 'request-reply' pattern over a message broker, where the caller sends a request and then blocks while waiting for a specific reply message."},
    {"name": "asynchronous_connector", "description": "A non-blocking interaction where the caller sends a message and immediately continues its own work without waiting for a response (like sending an email or a text message). **Identification Clues:** This is the standard model for any communication using a **Message Broker** (e.g., publishing a message to a Kafka or RabbitMQ topic). Also, look for **webhook** or **callback** patterns where a service is notified at a later time. An HTTP call can be used asynchronously if the code makes the request but does not block to wait for the server's response."},
    {"name": "indirect_relation_via_api", "description": "A logical connection between two components that interact through an intermediary, such as an API Gateway or Facade, rather than a direct network call. **Identification Clues:** This is inferred by analyzing the routing rules of a gateway."},
    {"name": "in_memory_connector", "description": "A direct connection between two components running within the same application process. This communication happens directly through function calls or shared memory and does not involve any network calls. **Identification Clues:** This is identified when one component's code **directly instantiates** and **calls methods** on an object from another component. Another clue is communication through a shared in-memory data structure (like a local queue). The defining characteristic is the complete absence of network client code (like HTTP or gRPC) for the interaction."},
    {"name": "database_connector", "description": "A connection from an application component to a database, used for creating, reading, updating, or deleting data. **Identification Clues:** Look for the use of specific **database drivers or client libraries** in the code or dependencies (e.g., `pymongo` for Python, `JDBC` for Java). The presence of **database connection strings** in configuration files is another strong indicator."},
    {"name": "service_connector", "description": "A generic stereotype for a direct connection between two application services, typically for request-response style interactions. Prefer a more specific type like 'RESTful HTTP' or 'gRPC' if possible."},
    {"name": "web_connector", "description": "A connector that uses standard web protocols, primarily HTTP/S. **Identification Clues:** Look for any use of HTTP client libraries (`requests`, `axios`, `fetch`) or web server frameworks (`Flask`, `Express`). URLs starting with `http://` or `https://` are a definitive clue."},
    {"name": "loosely_coupled_connector", "description": "A high-level category for any connection that reduces direct dependencies between components, such as communication via a message broker."},
    {"name": "ldap", "description": "The Lightweight Directory Access Protocol. A specialized protocol for querying directory services. **Identification Clues:** Look for dependencies on LDAP client libraries (e.g., `python-ldap`). Connection strings will start with `ldap://`."},
    {"name": "memcached_connector", "description": "The specific protocol used to communicate with a Memcached in-memory caching server. **Identification Clues:** Identify this when a service makes calls to a `Memcached DB` component using a Memcached client library."},
    {"name": "messaging", "description": "Components communicate by sending messages, usually via a central Message Broker."},
    {"name": "linked_to_middleware_handler", "description": "A connection that is intercepted by a piece of middleware code before it reaches the main application logic. **Identification Clues:** This is a code-level pattern. In Express.js, look for `app.use(...)`. In Flask, look for decorators like `@app.before_request`. In Java Spring, look for implementations of the `Filter` interface."},
]

CONNECTOR_STEREOTYPE_HIERARCHY_MAP = {
    "synchronous_connector": [
        {"name": "sync_async_connector", "description": "A component or connection that supports both blocking (synchronous) and non-blocking (asynchronous) communication styles, allowing clients to choose the interaction mode. **Identification Clues:** Look for a single service that implements both types of communication. For example, a component that has both a **RESTful HTTP** API for synchronous requests and also publishes or subscribes to a **Message Broker** for asynchronous notifications. **gRPC** services that define both unary (sync) and streaming (async) methods are another primary example."},
    ],
    "asynchronous_connector": [
        {"name": "sync_async_connector", "description": "A component or connection that supports both blocking (synchronous) and non-blocking (asynchronous) communication styles, allowing clients to choose the interaction mode. **Identification Clues:** Look for a single service that implements both types of communication. For example, a component that has both a **RESTful HTTP** API for synchronous requests and also publishes or subscribes to a **Message Broker** for asynchronous notifications. **gRPC** services that define both unary (sync) and streaming (async) methods are another primary example."},
        {"name": "callback", "description": "A type of asynchronous interaction where a caller makes a request to another service to start a long-running task and also provides a 'callback address' (like a webhook URL). The second service then sends a message to this address at a later time when its work is complete. **Identification Clues:** The most common implementation is a **webhook**. Look for code that makes an outbound API call and includes a parameter like `callback_url` or `notification_url` in the request body. The same service will also have a corresponding inbound API endpoint designed to receive this asynchronous notification."},
        {"name": "polling", "description": "A type of asynchronous interaction where a client repeatedly sends requests to a server at a set interval to check for a result or status update (e.g., 'Are you done yet?'). This is often used when the server cannot push updates to the client. **Identification Clues:** Look for code that contains a **loop** (like a `while` loop) that makes a network request and then **pauses** for a fixed time using a function like `time.sleep()` or `setInterval()` before repeating. The client will typically poll a status endpoint until the status is 'complete'."},
        {"name": "one_way", "description": "A type of asynchronous interaction where a component sends a message to another system with no expectation of a response. This is a true 'fire-and-forget' pattern (like dropping a letter in a mailbox). **Identification Clues:** This is common in event-driven systems where a service **publishes** an event to a **Message Broker** and does not wait for a reply. Sending data to a logging service or over a **UDP** socket are also one-way interactions. The key is the complete absence of any code or logic to handle a response."},
    ],
    "in_memory_connector": [
        {"name": "contains", "description": "A strong form of in-memory connection representing a 'part-of' relationship, where one component is an integral and internal part of another. The contained component's lifecycle is managed by its container. **Identification Clues:** This is identified when one component's code **instantiates another component inside its own constructor** (`__init__` in Python). The contained component cannot exist independently and is always deployed as part of its container."},
    ],
    "database_connector": [
        {"name": "jdbc", "description": "A standard Java API for connecting Java applications to databases. **Identification Clues:** This is specific to **Java** projects. Look for `import java.sql.*` statements and dependencies on JDBC drivers in `pom.xml` or `build.gradle`. Connection strings will start with `jdbc:`."},
        {"name": "odbc", "description": "A standard C-language API for accessing databases, commonly used on various platforms, including Windows. **Identification Clues:** Look for dependencies on ODBC libraries (e.g., `pyodbc` for Python) or the configuration of an ODBC Data Source Name (DSN)."},
        {"name": "mongo_wire", "description": "The native, low-level protocol used by all official MongoDB clients to communicate with a MongoDB server. **Identification Clues:** Select this for any connection to a `mongo_db` component. Connection strings will start with `mongodb://`."},
        {"name": "hdfs", "description": "The protocol for communicating with the Hadoop Distributed File System, used for large-scale big data storage. **Identification Clues:** Look for dependencies on **Apache Hadoop** or **Spark** libraries. Connection URIs will start with `hdfs://`."},
        {"name": "resp", "description": "The Redis Serialization Protocol, used by clients to send commands to a Redis server. **Identification Clues:** Select this for any connection to a `redis_db` component."},
        {"name": "mysql_protocol", "description": "The native network protocol used by clients to communicate with MySQL or MariaDB database servers. **Identification Clues:** Select this for any connection to a `mysql_db` component."},
        
    ],
    "service_connector": [
        {"name": "restful_http", "description": "An architectural style for web APIs that uses standard HTTP methods (GET, POST, PUT, DELETE) and typically exchanges data using JSON. **Identification Clues:** Look for the use of web frameworks like **Spring Boot (`@RestController`)**, **Flask**, or **Express.js**. The code will define routes that map HTTP verbs to functions."},
        {"name": "soap", "description": "A standardized protocol for exchanging structured information using XML. It's often used in enterprise or legacy systems. **Identification Clues:** Look for **XML** payloads structured inside a `<soap:Envelope>`. The service contract is defined by a **WSDL** file."},
        {"name": "avro", "description": "An RPC and data serialization framework often used in big data ecosystems. **Identification Clues:** Look for schema definitions in **`.avsc` files** (which are written in JSON). It is frequently used with Apache Kafka."},
        {"name": "grpc", "description": "A high-performance RPC framework from Google that uses Protocol Buffers for defining services. **Identification Clues:** The most definitive clue is the presence of **`.proto` files**. In Python projects, look for generated code files ending in `_pb2.py` and `_pb2_grpc.py` and dependencies like `grpcio`."},
        {"name": "thrift", "description": "An RPC framework from Apache, similar to gRPC. **Identification Clues:** Look for service interface definitions in **`.thrift` files** and dependencies on Apache Thrift libraries."},
    ],
    "web_connector": [
        {"name": "http", "description": "The standard, unencrypted Hypertext Transfer Protocol. **Identification Clues:** Look for connection URLs that begin with `http://`. This is common for local development but insecure for production traffic."},
        {"name": "https", "description": "A secure version of HTTP where the connection is encrypted using TLS/SSL. **Identification Clues:** Look for connection URLs that begin with `https://`. In server configurations (like NGINX), look for directives that specify SSL certificates and listening on port 443."},
        {"name": "http2", "description": "A major revision of the HTTP protocol designed for lower latency and higher efficiency. **Identification Clues:** This is most often found in server configurations. In NGINX, look for the `http2` keyword in the `listen` directive (e.g., `listen 443 ssl http2;`). gRPC uses HTTP/2 by default."},
    ],
    "loosely_coupled_connector": [
        {"name": "event_based_connector", "description": "A style of messaging where messages are 'events' – notifications that something significant has happened. The publisher of the event does not know who is listening. Prefer a more specific type like 'publisher' or 'subscriber' if possible."},
        {"name": "publisher", "description": "A component in a publish-subscribe pattern that sends event messages to a specific topic, without knowing who the receivers are. **Identification Clues:** Look for code using a messaging client to `publish` or `send` messages to a named **topic** or **exchange** (e.g., in Kafka or RabbitMQ)."},
        {"name": "subscriber", "description": "A component in a publish-subscribe pattern that registers interest in a specific topic and receives and processes events from it. **Identification Clues:** Look for code that creates a `subscription` to a **topic** or uses a listener/handler function (e.g., `@KafkaListener`) that is triggered when a message arrives."},
    ],
    "messaging": [
        {"name": "kafka_protocol", "description": "The specific wire protocol used to communicate with an Apache Kafka message broker. **Identification Clues:** Identify this when a `Message Broker` component is specifically `kafka` and other services use Kafka client libraries to connect."},
        {"name": "message_producer", "description": "A general component that sends a message (which can be a command or an event) to a message broker. This is a broader term than Publisher. **Identification Clues:** The clues are similar to Publisher; look for any code that sends messages to a broker."},
        {"name": "message_consumer", "description": "A component that receives and processes messages, typically from a specific point-to-point queue. Unlike a Subscriber, a Consumer often processes a message that is then removed from the queue. **Identification Clues:** Look for code that pulls messages from a named **queue** (not a topic) and processes them, often in a listening loop."},
        {"name": "jms", "description": "The Java Message Service is a Java API standard for communicating with enterprise-grade message brokers. **Identification Clues:** This applies **exclusively to Java projects**. Look for `import javax.jms.*` statements in the code. In build files (`pom.xml`, `build.gradle`), look for dependencies like `javax.jms-api` or `spring-boot-starter-activemq`."},
        {"name": "stomp", "description": "The Simple (or Streaming) Text Orientated Messaging Protocol is a simple, text-based protocol designed for easy implementation across many languages. **Identification Clues:** It is very commonly used for **WebSockets**. In a web application, look for JavaScript libraries like `stomp.js` or `sockjs-client`. In a backend (like Spring), look for configuration enabling STOMP endpoints (e.g., `@EnableWebSocketMessageBroker`)."},
    ],
}

SECURITY_CONNECTOR_ANNOTATIONS = {
    "authentication_connector": [
        {"name": "authentication_with_plaintext_credentials", "description": "A high-risk, insecure method where a client authenticates using a hardcoded username and password sent in clear text. **Identification Clues:** Look for connection strings or code that explicitly contain 'user=', 'username=', 'password=', or 'pass=' followed by a non-variable, hardcoded string. Prefer a more specific type like 'http_basic_authentication' or 'form_based_login_authentication' if possible."},
        {"name": "authentication_with_api_keys", "description": "A common authentication method where the client presents a static, pre-shared secret key to the server. **Identification Clues:** Look for HTTP requests that include headers like `Authorization: Api-Key YOUR_KEY_HERE`, `X-API-Key: YOUR_KEY_HERE`, or a query parameter like `?api_key=YOUR_KEY_HERE`."},
        {"name": "protocol_based_secure_authentication", "description": "A category for authentication mechanisms that rely on established, secure protocols rather than simple static credentials. Prefer a more specific type like 'ssl_authentication' or 'sasl_authentication' if possible."},
        {"name": "secure_authentication_token", "description": "A category for authentication where the client presents a temporary, securely generated token to prove its identity. Prefer a more specific type like ''open_id_connect_identity_token if possible."},
        {"name": "http_basic_authentication", "description": "An insecure, standard HTTP scheme where credentials are sent as a Base64-encoded, but not encrypted, string in the `Authorization` header. **Identification Clues:** Look for client code that sets an `Authorization: Basic <credentials>` header. On the server side, look for middleware or configurations that enable or require 'Basic Auth' on certain endpoints."},
        {"name": "form_based_login_authentication", "description": "The common website login method where a user submits their username and password through an HTML form. The browser sends these credentials, typically in a POST request body, to a login endpoint. **Identification Clues:** In front-end code, look for an HTML `<form>` with `<input type='password'>`. In back-end code, look for a route (e.g., `/login`, `/signin`) that handles a POST request and extracts user credentials from the request body to validate them."},
        {"name": "ssl_authentication", "description": "Also known as mutual TLS (mTLS), this is a highly secure method where the client authenticates itself to the server using its own public/private key pair and SSL/TLS certificate. **Identification Clues:** Look for client-side connection configurations that specify a `keystore`, `truststore`, `client.crt`, or `client.key`. This is different from server-side SSL, as the *client* is presenting its own unique certificate."},
        {"name": "sasl_authentication", "description": "Simple Authentication and Security Layer (SASL) is a framework used by various network protocols (like Kafka, LDAP, SMTP) for authentication. **Identification Clues:** Look for connection properties in configuration files that start with `sasl.`, such as `sasl.mechanism` (with values like 'PLAIN', 'GSSAPI', 'SCRAM-SHA-256') or `sasl.jaas.config`."},
        {"name": "open_id_connect_identity_token", "description": "Authentication is performed by validating an OIDC Identity Token, which is typically a JSON Web Token (JWT). This proves the identity of the end-user or client application. **Identification Clues:** Look for code that receives a request, extracts a JWT from the `Authorization: Bearer <token>` header, and then validates the token's signature and claims against an OIDC provider's public keys. The token being validated is specifically an `id_token`, not just an opaque access token."},
        {"name": "no_authentication", "description": "A security vulnerability where a connection that should be protected lacks any authentication mechanism. This applies to connectors that access private data or perform sensitive operations without verifying the client's identity. **Identification Clues:** Look for API calls to sensitive endpoints that are missing any form of authentication, such as an `Authorization` header, API key, or session cookie validation."},
        {"name": "authentication_not_required", "description": "A deliberate design choice where a connection is intentionally left public because it accesses non-sensitive, publicly available information. **Identification Clues:** Look for connections to endpoints that are explicitly public by nature, such as a server health check, public data feeds, or endpoints serving public documentation and assets."},
    ],
    "authentication_scope": [
        {"name": "authentication_scope_none", "description": "A potential vulnerability where authentication middleware is available in a component but is not applied to any incoming connections or routes, leaving the entire component unprotected. **Identification Clues:** Look for the import of authentication libraries or middleware that are never actually used in the application's request pipeline or on any specific routes."},
        {"name": "authentication_scope_some_requests", "description": "A selective security policy where authentication is required for certain sensitive connections, while other endpoints are intentionally public. **Identification Clues:** Look for authentication middleware being applied to specific, individual API routes or routers rather than globally to the entire application."},
        {"name": "authentication_scope_all_requests", "description": "A strong security posture where a global authentication policy protects all incoming connections by default. Exceptions must be explicitly configured. **Identification Clues:** Look for authentication middleware being applied at the application level, before any specific routes are defined."},
    ],
    "authorization_connector": [
        {"name": "no_authorization", "description": "A critical security vulnerability where a connector, despite having authentication, lacks any authorization checks. This means the system verifies who the user is but fails to check what they are allowed to do. **Identification Clues:** Look for authenticated endpoints that access or modify resources using only a user or client ID, without any logic to verify roles, permissions, or ownership."},
        {"name": "authorization_not_required", "description": "A deliberate design choice where a connector accesses a public resource that does not require any specific permissions to view or use, such as a public product catalog or a documentation page. **Identification Clues:** This applies to authenticated endpoints that are explicitly meant to be accessible by any authenticated user, regardless of their role."},
        {"name": "authorization_with_plaintext_information", "description": "An insecure practice where a client's permissions or roles are sent as unencrypted, plaintext values, often in request headers. **Identification Clues:** Look for custom headers like `X-User-Role: admin` or `X-Permissions: create,read` being sent from the client and trusted by the server without cryptographic validation."},
        {"name": "encrypted_authorization_information", "description": "A general category for secure authorization where permissions are conveyed within an encrypted payload or a cryptographically signed token. Prefer a more specific token-based type if applicable."},
        {"name": "token_based_authorization", "description": "A common authorization pattern where a client presents a security token (like a JWT or an opaque access token) to the server with each request to prove its permissions. **Identification Clues:** Look for an `Authorization: Bearer <token>` header being sent and validated by the server. Prefer a more specific type like 'oauth2_access_token_authorization' or 'oauth2_jwt_token_authorization' if possible."},
        {"name": "oauth2_access_token_authorization", "description": "Authorization is determined by an OAuth2 access token. The server typically treats this token as an opaque string and validates it by making a separate call to the authorization server's introspection or user info endpoint to get the user's permissions. **Identification Clues:** Look for code that receives a bearer token and then makes a server-to-server HTTP call to an external identity provider to validate it."},
        {"name": "oauth2_jwt_token_authorization", "description": "Authorization is determined by inspecting the claims inside a self-contained JSON Web Token (JWT). After cryptographically verifying the token's signature, the server checks claims like `scope` or `roles` directly from the token's payload to enforce permissions without needing to call an external service. **Identification Clues:** Look for the use of a JWT library to decode and verify a bearer token. The code will then have logic that directly reads claims from the decoded token object."},
    ],
    "authorization_scope": [
        {"name": "authorization_scope_none", "description": "A potential vulnerability where, after successful authentication, no further authorization checks are performed to verify a user's permissions for any request. This means any authenticated user can access all functions and data. **Identification Clues:** Look for code where a user's identity is confirmed, but that identity is never used to check against roles, permissions, or ownership before an action is taken."},
        {"name": "authorization_scope_some_requests", "description": "A selective security model where authorization is enforced on certain sensitive actions or data, while other general actions are available to any authenticated user. **Identification Clues:** Look for authorization middleware or permission-checking logic being applied to specific, individual API routes (e.g., routes for administrative tasks or deleting data) but not globally to all routes."},
        {"name": "authorization_scope_all_requests", "description": "A strong, 'default-deny' security posture where every request from an authenticated user is checked against an authorization policy to determine if they have the required permissions for that specific action. **Identification Clues:** Look for a global authorization middleware that intercepts all requests after authentication. This middleware would typically check the user's roles or permissions against an access control list (ACL) for the requested route and method."},
    ],
    "sensitive_data_in_connector_code": [
        {"name": "connector_code_no_sensitive_data", "description": "The ideal security practice where the client-side code for establishing a connection is completely free of hardcoded secrets. Credentials are loaded from a secure external source at runtime. **Identification Clues:** Look for the use of environment variables (e.g., `os.getenv('API_KEY')`), or client libraries for secret management services like HashiCorp Vault or AWS Secrets Manager to build the connection configuration."},
        {"name": "connector_code_plaintext_sensitive_data", "description": "A critical vulnerability where secrets like passwords or API keys are hardcoded in clear text within source code or configuration files. **Identification Clues:** Look for connection strings or client initializations that use literal, hardcoded strings for credentials (e.g., `psycopg2.connect('user=admin pass=123...')`). The presence of keywords like 'password' or 'secret' assigned to a string literal is a strong indicator."},
        {"name": "connector_code_encrypted_sensitive_data", "description": "A good security practice where sensitive data is present in configuration files but is encrypted. The application code is responsible for decrypting the data before making the connection. **Identification Clues:** Look for configuration values with a specific encrypted format (e.g., `ENC(...)` in a Java Spring `application.properties` file) and the inclusion of a corresponding decryption library like Jasypt in the project's dependencies."},
        {"name": "connector_code_encrypted_token_sensitive_data", "description": "A specific, secure pattern where the sensitive data used for the connection is contained within a cryptographically encrypted token, such as a JSON Web Encryption (JWE) token. **Identification Clues:** Look for the use of a JWE library to parse and decrypt a token. The code will specifically handle the decryption of a structured token, not just a simple string."},
    ],
    "communication_security": [
        {"name": "encrypted_communication", "description": "Represents a secure connection where data in transit is protected from eavesdropping using cryptographic protocols like TLS/SSL. **Identification Clues:** Look for connection URLs that use secure schemes like `https://`, `grpcs://`, or `amqps://`. For databases, look for connection options like `ssl=true` or `sslmode=require`."},
        {"name": "unencrypted_communication", "description": "Represents an insecure connection where data is sent in plaintext, making it vulnerable to interception. This is a critical vulnerability if any sensitive data is transmitted. **Identification Clues:** Look for connection URLs using insecure schemes like `http://` or `grpc://`, or the absence of any SSL/TLS configuration in a database connection string."},
    ]
}